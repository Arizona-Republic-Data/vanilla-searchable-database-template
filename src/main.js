import { FilteringDataTable } from "./datatable";
import { trackEvent } from "./analytics";

import "../node_modules/simple-datatables/src/style.css";
import "./style.css";

/**
 * Searchable database app.
 *
 * @property {String} appSlug - A slug identifying this particular database in
 *   custom analytics events.
 * @property {string|number} idCol - Column that contains a unique identifier
 *   for each record. This defaults to `_id`, which means an id will be
 *   generated based on row order.
 * @property {Map} columnTransforms - Map from column name to a function to
 *   modify or add columns. Functions take a single record and return a
 *   value that will be added to the record. Consider doing this data
 *   transformation in the preprocessing script instead of at runtime.
 * @property {String} filterCol - Column with categorical data that will be
 *   used to populate a filter select element.
 * @property {Map} displayHeadings - Defines which columns will be shown
 *   in the table and the column name that will be shown in the table
 *   heading. Configuring this property both allows for filtering
 *   columns to a subset of the ones in the data and making more
 *   readable names. Note that columns in the data that are not
 *   included in this property can still be shown in the detail view.
 * @property {String} defaultSort - Column name used to define the default
 *   sorting of the table. Consider pre-sorting the data in the
 *   preprocessing script for better performance.
 * @property {Set} sortable - Column names for columns that the user can
 *   sort in the table.
 * @property {Map} renderFuncs - Functions used to render columns in the table.
 * @property {String} filterLabel - Label that will be shown in the filter select
 *   element if the user has not selected any category to filter.
 * @property {String} resetLabel - Label that will be shown in the filter select
 *   element for the option that will reset the filter.
 * @property {String} dataUrl - URL of data that will be shown in the table.
 *   Default is `data/data.json`.
 */
export class SearchableDatabase {
  // Configuration properties
  //
  // See the docstring for this class above for descriptions.
  // You will want to change these for your particular data.

  // @todo Change this to uniquely identify your app in analytics data.
  appSlug = "searchabledb";
  // @todo Change this if your data has a unique ID for each record. If left
  // unchanged, one will be generated by row order.
  idCol = "_id";
  // @todo Add elements to this array if you want to preprocess your data.
  // However, consider doing this in your data processing script instead.
  columnTransforms = new Map([]);
  // @todo Change this to match the column name of the column you want to
  // use to populate the filter select element.
  filterCol = "forestname";
  // @todo Update this with the list of columns you want to be shown in the
  // rendered table and the more readable column heading.
  displayHeadings = new Map([
    ["id", "Authorization ID"],
    ["forestname", "Forest Name"],
    ["contact_name", "Contact"],
    ["issue_date", "Issue Date"],
  ]);
  // @todo Set this to a column name if you want that column to define the
  // default sort of the table. Consider pre-sorting the data in the
  // preprocessing script for better performance.
  defaultSort = null;
  // @todo Update this with all the names of columns that you want the user
  // to be able to sort.
  sortable = new Set(["issue_date"]);
  // @todo Update this with elements that are pairs of column names and
  // functions to render the columns in the table.
  renderFuncs = new Map([]);
  // @todo Change this if you want the default item in the filter select
  // element to have a different label.
  filterLabel = "Filter by category";
  // @todo Change this if you want a different label for the option that
  // will cause the filter to be reset when the user has selected a filter.
  resetLabel = "Reset filter";
  // @todo Change this if you're showing data outside this project or have
  // changed the data filename.
  dataUrl = "data/data.json";

  /**
   * Initialize and render a searchable table.
   *
   * @param {HTMLElement} containerEl Container element for the entire app.
   * @param {HTMLElement} tableEl Table that will be populated with our data.
   * @param {HTMLElement} selectEl Element for the select input that will be used
   *   to filter by category.
   * @param {IFrameResizer} resizer Gannett resizer object. We need to pass this
   *   to our app because sometimes we have to explicitly trigger a resize because
   *   the library doesn't correctly detect when the table grows.
   * @param {function} ga Google Analytics function.
   */
  constructor(containerEl, tableEl, selectEl, resizer, ga) {
    // Initialize instance properties
    this.containerEl = containerEl;
    this.tableEl = tableEl;
    this.selectEl = selectEl;
    this.resizer = resizer;
    this.ga = ga;
    this.records = [];
    this.recordsMap = new Map();
    this.categories = new Set();
    this.eventTracker = trackEvent.bind(null, this.ga, this.appSlug);

    if (!this.displayHeadings.has(this.idCol)) {
      // If the heading name for the ID column hasn't been specified in the
      // class declaration, initialize it to an empty string. This is
      // because, by default, the ID column is rendered as the button that
      // toggles the detail view.
      this.displayHeadings = new Map([
        [this.idCol, ""],
        ...this.displayHeadings.entries(),
      ]);
    }

    // Finish initialization
    this.init();
  }

  /**
   * Perform initialization that requires asynchronous calls.
   *
   * This is a bit of a hack required because we need to await the fetching
   * of the data, but the constructor shouldn't be async.
   * See https://stackoverflow.com/questions/43431550/async-await-class-constructor
   * for more thoughts on this situation.
   */
  async init() {
    // @todo Consider pre-rendering most important columns and then adding data
    // or hydrating dynamically.
    // See https://github.com/fiduswriter/Simple-DataTables/wiki/Adding-a-column-from-a-remote-source
    await this.fetchData();

    this.processData();

    if (!this.renderFuncs.has(this.idCol)) {
      // By default, render the ID column as a button that toggles the detail
      this.renderFuncs.set(
        this.idCol,
        SearchableDatabase.renderToggleDetailCol
      );
    }

    if (this.displayHeadings.size === 0) {
      // If headings haven't been overridden, just use the ones in the first
      // record.
      Object.keys(records[0]).forEach((prop) => {
        this.displayHeadings.set(prop, prop);
      });
    }

    this.initTable();
  }

  /**
   * Fetch the data that will be shown in the table.
   */
  async fetchData() {
    const response = await fetch(this.dataUrl);
    this.records = await response.json();

    return this;
  }

  /**
   * Add new (and rarely, remove or transform) properties to each record based
   * on existing columns.
   *
   * @param {Object} record Original record.
   * @param {Map} columnTransforms Map from the output column name to a function
   *   that takes the original record as input and returns the new or updated
   *   column value.
   *
   * @returns {Object} updated record with updated columns.
   */
  static transformColumns(record, columnTransforms) {
    const newColumns = {};

    for (columnName of columnTransforms.keys()) {
      newColumns[columnName] = columnTransforms[columnName](record);
    }

    return {
      ...record,
      ...newColumns,
    };
  }

  /**
   * Transform data and build a set of categories and lookup table of records.
   */
  processData() {
    this.records.forEach((record, i) => {
      if (this.idCol === "_id") {
        // Dynamically add an id to the data based on each complaint's
        // order.
        record[this.idCol] = i;
      }

      // Add or transform columns based on existing columns
      record = SearchableDatabase.transformColumns(
        record,
        this.columnTransforms
      );

      // Add to our list of filter categories.
      if (this.filterCol) {
        this.categories.add(record[this.filterCol]);
      }

      // Add to the lookup that goes from ID => complaint object
      this.recordsMap.set(record[this.idCol], record);
    });

    return this;
  }

  /**
   * Test if a table row matches a category
   *
   * @param {String} category Name of category
   * @param {Numeric} categoryColIdx Zero-based column index of the table column
   *   containing the category name
   * @param {HTMLElement} row Table row to check if it matches the category
   * @returns {Boolean} true if row matches the category, otherwise false
   */
  static filterByCategory(category, categoryColIdx, row) {
    const cell = row.cells[categoryColIdx];
    const content = cell.hasAttribute("data-content")
      ? cell.getAttribute("data-content")
      : cell.textContent;

    return content == category;
  }

  /**
   * Initialize filter by category.
   */
  initCategoryFilter(categoryColIdx) {
    this.categories.forEach((category) => {
      const option = document.createElement("option");
      option.setAttribute("value", category);
      option.innerHTML = category;

      this.selectEl.appendChild(option);
    });

    this.selectEl.children[0].innerHTML = this.filterLabel;

    this.selectEl.addEventListener("change", (evt) => {
      const selectedCategory = this.selectEl.value;

      if (selectedCategory === "") {
        this.selectEl.children[0].innerHTML = this.filterLabel;

        // Reset filter
        this.table.setFilter();
      } else {
        this.selectEl.children[0].innerHTML = this.resetLabel;

        this.table.setFilter(
          SearchableDatabase.filterByCategory.bind(
            null,
            selectedCategory,
            categoryColIdx
          )
        );

        this.eventTracker("filter industry", selectedCategory);
      }

      this.table.search(this.table.input.value);
    });

    this.selectEl.removeAttribute("disabled");
  }

  /**
   * Custom column rendering for the ID column.
   *
   * Returns HTML for a button that will be used to reveal details
   * about each complaint.
   *
   * @param {String} data The cell's content (innerHTML)
   * @param {Object} cell The HTMLTableCellElement
   * @param {Object} row The cell's parent HTMLTableRowElement
   * @returns {String} HTML for cell
   */

  static renderToggleDetailCol(data, cell, row) {
    return `
      <button class="show-detail" data-id="${data}" aria-label="Show details" title="Show details">
        <svg class="show-detail-icon" viewBox="0 0 10 6">
          <path d="M5 3.35L8.64 0 10 1.4 5 6 0 1.4 1.36 0z"></path>
        </svg>
      </button>
    `;
  }

  /**
   * Initialize the data table object.
   */
  initTable() {
    // Create a map of the property names in the data to their
    // numeric index, i.e. column number.
    // That just makes the code less brittle if we decide to reorder columns.
    this.columnIndices = new Map();

    const columnPropNames = [...this.displayHeadings.keys()];
    const columns = [];
    columnPropNames.forEach((prop, i) => {
      this.columnIndices.set(prop, i);

      const columnDef = {
        select: i,
        sortable: this.sortable.has(prop),
      };

      const renderFunc = this.renderFuncs.get(prop);
      if (renderFunc != null) {
        columnDef.render = renderFunc;
      }

      if (prop == this.defaultSort) {
        columnDef.sort = true;
      }

      columns.push(columnDef);
    });

    this.table = new FilteringDataTable(this.tableEl, {
      data: {
        // Use our cleaner headings
        headings: [...this.displayHeadings.values()],
        // Convert objects to arrays and only select a subset of all possible
        // columns.
        data: this.records.map((record) =>
          columnPropNames.map((prop) => record[prop])
        ),
      },
      columns: columns,
      perPage: 20,
      layout: {
        // Hide per-page select. This isn't something the user needs to control.
        top: "{search}",
        bottom: "{info}{pager}",
      },
    });

    this.initTableEvents();
  }

  /**
   * Render the detailed information about the record that isn't
   * automatically shown in the table.
   *
   * @todo Edit this to fit your data.
   *
   * @param {Object} record Record object
   * @returns {String} HTML for record details
   */
  static renderDetail(record) {
    // HACK: I'd probably declare this as module-level function or a static
    // method of the class in a real app, but I'm declaring it here to avoid
    // having bits lying around the template that are specific to the sample
    // data.
    const formatDate = (dateStr) => {
      // HACK: This isn't the most robust or portable date parsing approach,
      // but it's fine for an example.
      const date = new Date(dateStr);

      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
    };

    const useFields = ["use1_name", "use2_name", "use3_name"];
    const uses = useFields.reduce((prevUses, useField) => {
      const updatedUses = [...prevUses];

      if (record[useField]) {
        updatedUses.push(record[useField]);
      }

      return updatedUses;
    }, []);

    let usesHTML = uses.map((u) => `<li>${u}</li>`).join("");
    if (usesHTML !== "") {
      usesHTML = `
        <dt>Uses</dt>
        <dd><ul class="uses-list">${usesHTML}</ul></dd>
      `;
    }

    return `
      <dl>
        <div class="detail-field-group">
          <dt>Authorization ID</dt>
          <dd>${record.id}</dd>

          <dt>Ranger District</dt>
          <dd>${record.districtna ? record.districtna : ""}</dd>
        </div>

        <div class="detail-field-group">
          <dt>Issue Date</dt>
          <dd>${formatDate(record.issue_date)}</dd>

          <dt>Expiration Date</dt>
          <dd>${formatDate(record.exp_expiration_date)}</dd>
        </div>

        ${usesHTML}
      </dl>
    `;
  }

  /**
   * Returns a <tr> element with the record's detail content inside
   * @param {Object} record Complaint record
   * @param {Number} numCols Number of columns in a complaint row
   */
  static createDetailRow(record, numCols) {
    const detailRow = document.createElement("tr");
    const detailCell = document.createElement("td");

    detailRow.classList.add("detail-row");
    detailCell.setAttribute("colspan", numCols);
    detailCell.innerHTML = SearchableDatabase.renderDetail(record);

    detailRow.appendChild(detailCell);

    return detailRow;
  }

  /**
   * Update data and classes on a button element to indicate that the detail
   * is switching from being hidden to shown, or vice-versa
   *
   * @param {HTMLElement} button Button element that shows/hides a complaint
   *   detail
   * @returns {HTMLElement}
   */
  static toggleButtonState(button) {
    if (button.dataset.state == "open") {
      button.dataset.state = "closed";
      button.querySelector("svg").classList.add("show-detail-icon");
      button.querySelector("svg").classList.remove("hide-detail-icon");
    } else {
      button.dataset.state = "open";
      button.querySelector("svg").classList.add("hide-detail-icon");
      button.querySelector("svg").classList.remove("show-detail-icon");
    }

    return button;
  }

  /**
   * Event handler for clicking on button to show details.
   */
  handleClickDetail(evt) {
    const button = evt.currentTarget;
    const td = button.parentNode;
    const tr = td.parentNode;
    const tbody = tr.parentNode;
    const record = this.recordsMap.get(parseInt(button.dataset.id, 10));
    const numCols = tr.children.length;
    const detailState = button.dataset.state;

    if (detailState == "open") {
      // A record's detail view is opened. Close the detail view.

      tr.nextSibling.remove();

      tr.classList.remove("detail-open");
      tbody.classList.remove("detail-open");

      SearchableDatabase.toggleButtonState(button);

      this.sendHeight();

      return;
    }

    // A record's detail view is closed.
    // Show the detail view for the record using a table row
    // below the record.

    // But first, collapse any other open detail rows
    SearchableDatabase.closeAllDetails(tbody);

    tr.parentNode.insertBefore(
      SearchableDatabase.createDetailRow(record, numCols),
      tr.nextSibling
    );

    tr.classList.add("detail-open");
    tbody.classList.add("detail-open");

    SearchableDatabase.toggleButtonState(button);

    this.sendHeight();

    this.eventTracker("showdetail", record[this.labelProp]);
  }

  /**
   * Connect event handlers that will cause the detail view to be shown
   */
  connectDetailButtonHandlers(handler) {
    // Wire up click event handlers to reveal the detail view
    // @todo Should we use something other than a button?
    this.table.container
      .querySelectorAll("button.show-detail")
      .forEach((el) => {
        el.addEventListener("click", handler);
      });
  }

  /**
   * Close all open detail views
   * @param {HTMLElement} tbody <tbody> element for the data table
   */
  static closeAllDetails(tbody) {
    tbody.querySelectorAll("tr.detail-row").forEach((tr) => tr.remove());
    tbody.querySelectorAll("tr.detail-open").forEach((tr) => {
      tr.classList.remove("detail-open");
    });
    tbody
      .querySelectorAll("button[data-state='open']")
      .forEach(SearchableDatabase.toggleButtonState);
    tbody.classList.remove("detail-open");
  }

  /**
   * Safely notify the parent page that the iframe needs to be resized.
   */
  sendHeight() {
    if (this.resizer) {
      this.resizer.broadcast_height();
    }
  }

  /**
   * Connect event handlers for table events and for click events for elements
   * inside the table.
   */
  initTableEvents() {
    // Connect handlers that open the detail view for a row of the table
    // We have to bind these in the event handlers rather than the render
    // function because the render function just returns HTML text, not
    // the element.

    // We have to define the handler as a new variable and pass it to
    // this.connectDetailButtonHandlers() so that every handler is
    // the same function. That way, we can re-bind the handler without
    // accidentally binding multiple handlers.
    // See https://stackoverflow.com/a/47337711/386210
    const buttonHandler = this.handleClickDetail.bind(this);

    this.table.on("datatable.init", () => {
      // Change the search input to a search type.
      // In some browsers (Chrome, Safari), this causes a "x" icon to be shown
      // that clears the entire search term.
      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/search
      this.table.input.setAttribute("type", "search");
      // Add an event handler to clear the search when the user uses the x icon
      this.table.input.addEventListener("input", () => {
        if (this.table.input.value === "") {
          // Only do something when the input value is empty.
          // The library already provides its own `keyup` event listener.
          this.table.search("");
        }
      });

      // On the initial render of the table, wire up event listeners to open and
      // close the detail view. This will only connect events for the first
      // page of data.
      this.connectDetailButtonHandlers(buttonHandler);
    });

    // For subsequent pages, add event handlers when the new page is shown.
    // Also make sure any open detail views are closed.
    this.table.on("datatable.page", () => {
      SearchableDatabase.closeAllDetails(
        this.table.container.querySelector("tbody")
      );
      this.connectDetailButtonHandlers(buttonHandler);
    });
    // Do the same after a search or filter
    this.table.on("datatable.update", () => {
      SearchableDatabase.closeAllDetails(
        this.table.container.querySelector("tbody")
      );
      this.connectDetailButtonHandlers(buttonHandler);
    });

    // Wire up event handlers so that when the category filter is changed,
    // the table will be filtered to only complaints for workplaces in
    // that category.
    this.table.on(
      "datatable.init",
      this.initCategoryFilter.bind(this, this.columnIndices.get(this.filterCol))
    );

    this.table.on("datatable.search", (query) => {
      if (query) {
        // Track a custom event in analytics when the user searches.
        this.eventTracker("search", query);
      }
    });

    // Explictly tell the parent to resize the iframe when the content changes
    const sendHeightHandler = this.sendHeight.bind(this);
    this.table.on("datatable.init", sendHeightHandler);
    this.table.on("datatable.page", sendHeightHandler);
    this.table.on("datatable.update", () => {
      // HACK: Send the height, and then send it again a little later.
      sendHeightHandler();
      setTimeout(sendHeightHandler, 10);
    });
    window.addEventListener("resize", sendHeightHandler);
  }
}
